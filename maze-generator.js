// this code was initally generated by AI chatgpt
const width = 20;
const height = 20;

const grid = [];
for (let y = 0; y < height; y++) {
  grid[y] = [];
  for (let x = 0; x < width; x++) {
    grid[y][x] = 1;
  }
}

const directions = [
  { x: 0, y: -2 },
  { x: 0, y: 2 },
  { x: -2, y: 0 },
  { x: 2, y: 0 }
];

function isInBounds(x, y) {
  return x > 0 && x < width - 1 && y > 0 && y < height - 1;
}

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function generateMaze(x, y) {
  grid[y][x] = 0;
  shuffle(directions);

  for (const direction of directions) {
    const newX = x + direction.x;
    const newY = y + direction.y;

    if (isInBounds(newX, newY) && grid[newY][newX] === 1) {
      if (grid[newY - direction.y / 2][newX - direction.x / 2] === 1) {
        grid[newY][newX] = 0;
        grid[newY - direction.y / 2][newX - direction.x / 2] = 0;
        generateMaze(newX, newY);
      }
    }
  }
}

// Pilih pintu masuk dan pintu keluar secara acak di tepi grid
function setEntranceAndExit() {
  // Pintu masuk
  let entranceSet = false;
  while (!entranceSet) {
    const side = Math.floor(Math.random() * 4);
    switch (side) {
      case 0: // atas
        entranceX = Math.floor(Math.random() * (width - 2)) + 1;
        entranceY = 0;
        if (grid[entranceY + 1][entranceX] === 0) {
          grid[entranceY][entranceX] = 0;
          entranceSet = true;
        }
        break;
      case 1: // kanan
        entranceX = width - 1;
        entranceY = Math.floor(Math.random() * (height - 2)) + 1;
        if (grid[entranceY][entranceX - 1] === 0) {
          grid[entranceY][entranceX] = 0;
          entranceSet = true;
        }
        break;
      case 2: // bawah
        entranceX = Math.floor(Math.random() * (width - 2)) + 1;
        entranceY = height - 1;
        if (grid[entranceY - 1][entranceX] === 0) {
          grid[entranceY][entranceX] = 0;
          entranceSet = true;
        }
        break;
      case 3: // kiri
        entranceX = 0;
        entranceY = Math.floor(Math.random() * (height - 2)) + 1;
        if (grid[entranceY][entranceX + 1] === 0) {
          grid[entranceY][entranceX] = 0;
          entranceSet = true;
        }
        break;
    }
  }

  // Pintu keluar
  let exitSet = false;
  while (!exitSet) {
    const side = Math.floor(Math.random() * 4);
    switch (side) {
      case 0: // atas
        exitX = Math.floor(Math.random() * (width - 2)) + 1;
        exitY = 0;
        if (grid[exitY + 1][exitX] === 0 && (exitX !== entranceX || exitY !== entranceY)) {
          grid[exitY][exitX] = 0;
          exitSet = true;
        }
        break;
      case 1: // kanan
        exitX = width - 1;
        exitY = Math.floor(Math.random() * (height - 2)) + 1;
        if (grid[exitY][exitX - 1] === 0 && (exitX !== entranceX || exitY !== entranceY)) {
          grid[exitY][exitX] = 0;
          exitSet = true;
        }
        break;
      case 2: // bawah
        exitX = Math.floor(Math.random() * (width - 2)) + 1;
        exitY = height - 1;
        if (grid[exitY - 1][exitX] === 0 && (exitX !== entranceX || exitY !== entranceY)) {
          grid[exitY][exitX] = 0;
          exitSet = true;
        }
        break;
      case 3: // kiri
        exitX = 0;
        exitY = Math.floor(Math.random() * (height - 2)) + 1;
        if (grid[exitY][exitX + 1] === 0 && (exitX !== entranceX || exitY !== entranceY)) {
          grid[exitY][exitX] = 0;
          exitSet = true;
        }
        break;
    }
  }

  return { entrance: [entranceX, entranceY], exit: [exitX, exitY] };
}

// Generate maze and set entrance and exit
generateMaze(1, 1);
const { entrance, exit } = setEntranceAndExit();

console.log(grid)

console.log("Entrance:", entrance);
console.log("Exit:", exit);
